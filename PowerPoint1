🍴 Lunch & Learn: Intro to React
Slide 1: What is React?

On slide (bullets):

Open-source JS library (Facebook, 2011 → OSS 2013)

Built for complex UIs (ex: News Feed)

Core ideas:

Components

Declarative rendering

Virtual DOM

Transcript (what you say):
“React is an open-source JavaScript library for building user interfaces. It was created at Facebook by engineer Jordan Walke in 2011 and released as open source in 2013.

The original motivation was Facebook’s News Feed, which was incredibly complex. Think about it: new posts, comments, likes, notifications — all updating constantly. With traditional JavaScript or jQuery, developers had to manually tell the browser what to update step by step. That was error-prone, slow, and very hard to scale across a huge team of engineers.

React introduced two big ideas. First, a component-based model. Instead of one massive HTML file, you break the UI into small, reusable components. Each component is responsible for its own logic and styling, so apps become modular and easier to maintain.

The second idea is declarative programming. Instead of telling the DOM how to update, you just declare what the UI should look like given some state, and React takes care of the updates.

The secret sauce behind this is the Virtual DOM. React keeps a lightweight copy of the DOM in memory. When state changes, React re-renders that copy, compares it to the old one, and updates only what’s different in the real DOM. That makes UI updates efficient, predictable, and fast.”

Slide 2: How React Works — Imperative vs Declarative

On slide (bullets):

Imperative: manually update DOM step by step

Declarative: describe end state, React handles updates

Example: Counter → JS vs React

Transcript:
“Before React, front-end code was imperative. You’d write instructions like: ‘Find this element, update its text, add this class.’ That works for small sites but gets messy quickly.

React flips that to declarative UI. Instead of telling the browser step by step what to do, you just declare the end result: ‘The UI should look like this if count is 5.’ If the count changes to 6, React re-renders the component with the new value.

Here’s a simple example:

In plain JavaScript, you’d have a variable, a button, an event listener, and you’d manually update the DOM on every click.

In React, you write a Counter component that renders the button with the current count. When clicked, React updates the state and re-renders automatically.

So the big difference is: in plain JavaScript, we manage the DOM manually. In React, React manages the DOM for us. That shift is what makes React manageable for large, complex apps.”

Slide 3: JSX

On slide (bullets):

HTML-like syntax inside JS

Compiles to React.createElement

Embed JS in { }

Keeps UI + logic together

Transcript:
“One of React’s innovations is JSX. It looks like HTML inside JavaScript. JSX isn’t required, but almost everyone uses it because it makes components more expressive.

Under the hood, JSX compiles to React.createElement calls, so it’s just JavaScript.

The benefit is that you can embed JavaScript expressions directly in your UI. For example:

<h1>Hello {name}</h1>


When React renders this, it replaces {name} with the actual variable. JSX keeps the structure of your UI close to the logic that powers it, which makes code easier to understand.”

Slide 4: Components

On slide (bullets):

Building blocks of React apps (like Lego)

Reusable → update once, update everywhere

Benefits:

Easier to isolate & debug

Encourages clean architecture

Simplifies testing

Improves team collaboration

Transcript:
“Components are the building blocks of a React app. You can think of them as Lego pieces.

They can be as small as a Button or as large as an entire Page.

The power of components is reusability. If you build a Card component once, you can use it throughout your app. If the design changes, update the Card component and every instance updates automatically.

But there’s more: components make apps easier to isolate and debug — if something breaks, you can test just that piece. They encourage clean architecture because you naturally separate concerns. They also make collaboration easier — one dev can build a Navbar while another builds a Profile component, and the two fit together.

This modular approach is why React scales so well in big projects.”

Slide 5: Props & State

On slide (bullets):

Props = inputs from parent (read-only)

Make components configurable & reusable

Predictable, top-down data flow

State = internal, dynamic data

Triggers re-render on change

Manages user input, toggles, counters

Together: drive interactivity

Transcript:
“Props and state are what make components dynamic.

Props are like function arguments — inputs from a parent. They’re read-only, so the child can’t change them. This makes components predictable and reusable: pass in a different prop, get a different output.

State is internal to a component. It’s for data that changes over time: like a form field, a counter, or whether a dropdown is open. When state changes, React re-renders the component automatically.

For example, a Profile might receive a user prop from its parent, but internally manage an isEditing state. Props let us configure a component, while state lets it stay interactive. Together, props and state are what bring React components to life.”

Slide 6: Parent/Child Relationships & Prop Drilling

On slide (bullets):

Components form a tree

Data flows top → down via props

Prop drilling: passing through layers unnecessarily

Solutions: Context API, state libraries (Redux, Zustand, Recoil)

Transcript:
“React apps are structured like a tree. The App component is at the top, and it renders children, which render more children, and so on.

Parents pass data to children through props, which keeps the data flow one-way — top to bottom. That makes React predictable.

But sometimes you hit prop drilling. Let’s say App has user data, but a deeply nested component needs it. You might end up passing that prop through several components that don’t even use it, just to get it to the right place.

That works, but it gets messy. To solve it, React provides the Context API for sharing values globally, and for larger apps, state libraries like Redux or Zustand. Props are always the starting point, but they’re not always enough.”

Slide 7: Hooks — Why They Matter

On slide (bullets):

Introduced in React 16.8 (2019)

Add state & lifecycle to functions

Replace many class patterns

Composable → can build custom hooks

Transcript:
“Hooks were introduced in React 16.8 in 2019, and they completely changed how we write React.

Before hooks, you had to use class components with lifecycle methods. That made code harder to reuse and reason about.

Hooks let us put state, side effects, and other logic directly into functional components. They’re how React knows what values to watch and when to re-render. They’re also composable — you can combine built-in hooks into your own custom hooks, which we’ll see later.”

Slide 8: Core Hooks — useState and useEffect

On slide (bullets):

useState: local state, triggers re-render

useEffect: side effects after render

Data fetching

Subscriptions

DOM updates

Transcript:
“Let’s start with the two most common hooks.

useState lets you store a value in a component. It gives you a value and a setter function. When you call the setter, React re-renders with the new value. That’s the foundation of interactivity.

useEffect is for side effects — things outside of rendering, like fetching data, setting up a subscription, or updating the document title. React runs these effects after rendering, and you can control when they run with dependencies.

So together:

useState → manages data inside your component.

useEffect → manages interactions with the outside world.”

Slide 9: Performance Hooks — useMemo and useRef

On slide (bullets):

useMemo: cache expensive calculations

useRef: persist values across renders

Reference DOM nodes

Store values (timers, counters, etc.)

Transcript:
“React also gives us hooks for performance and special cases.

useMemo memoizes expensive calculations so they don’t re-run every render. For example, sorting a large list or running a heavy computation.

useRef is like a box that persists between renders but doesn’t trigger re-renders. You can use it to store values like timers, or to reference DOM elements like an input field so you can call inputRef.current.focus().

These hooks let you fine-tune performance and control how your app behaves.”

Slide 10: Custom Hooks

On slide (bullets):

Functions built on hooks (must start with use)

Encapsulate reusable logic

Example: useFetch for data loading

Benefits: cleaner, DRY, reusable

Transcript:
“On top of the built-in hooks, React lets us create custom hooks.

A custom hook is just a function that uses other hooks. By convention, it starts with use.

This is great for reusing logic across components. For example, if multiple components need to fetch data, instead of repeating the fetch code, you can write a useFetch hook. Then any component can call useFetch('/api/users') and get back the data and loading state.

Custom hooks keep components clean, reduce duplication, and make business logic reusable.”

Slide 11: Wrap-Up

On slide (bullets):

React solves complex, dynamic UIs

Core: Components, Declarative UI, Virtual DOM

Props & State = interactivity

Hooks = connect data to UI

Custom Hooks = reusable logic

Scales from small apps → enterprise

Transcript:
“To wrap up:

React was created at Facebook to manage complex, constantly updating UIs.

Its key ideas are components, declarative rendering, and the Virtual DOM.

Props and state drive interactivity.

Hooks — especially useState, useEffect, useMemo, and useRef — connect data changes to UI updates.

And custom hooks let us reuse logic across components.

The reason React is still so dominant today is because it balances simplicity for small apps with scalability for large apps.

So whether you’re building a small widget or a full enterprise system, React gives you a strong foundation to work from.”
